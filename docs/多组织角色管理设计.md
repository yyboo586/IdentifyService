# 多组织角色管理设计

## 1. 数据库设计

### 1.1 角色表结构调整

```sql
CREATE TABLE IF NOT EXISTS `t_role`  (
  `id` INT(10) NOT NULL AUTO_INCREMENT,
  `org_id` INT(10) NOT NULL COMMENT '组织ID',
  `pid` INT(10) NOT NULL COMMENT '父级ID',
  `name` VARCHAR(20) NOT NULL COMMENT '角色名称',
  `status` TINYINT(4) NOT NULL COMMENT '状态',  
  `creator_id` VARCHAR(40) NOT NULL COMMENT '创建人ID',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  INDEX `idx_org_id`(`org_id`),
  INDEX `idx_pid`(`pid`),
  INDEX `idx_name`(`name`),
  INDEX `idx_creator_id`(`creator_id`),
  UNIQUE KEY `uk_org_name`(`org_id`, `name`) COMMENT '同一组织下角色名称唯一'
) ENGINE = InnoDB COMMENT = '角色表';
```

### 1.2 组织表设计

```sql
CREATE TABLE IF NOT EXISTS `t_org`  (
  `id` INT(10) NOT NULL AUTO_INCREMENT,
  `pid` INT(10) NOT NULL DEFAULT 0 COMMENT '父级组织ID',
  `name` VARCHAR(50) NOT NULL COMMENT '组织名称',
  `code` VARCHAR(20) NOT NULL COMMENT '组织编码',
  `status` TINYINT(4) NOT NULL DEFAULT 1 COMMENT '状态：1启用，0禁用',
  `sort` INT(10) NOT NULL DEFAULT 0 COMMENT '排序',
  `creator_id` VARCHAR(40) NOT NULL COMMENT '创建人ID',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  INDEX `idx_pid`(`pid`),
  INDEX `idx_code`(`code`),
  INDEX `idx_creator_id`(`creator_id`)
) ENGINE = InnoDB COMMENT = '组织表';
```

## 2. 业务逻辑调整

### 2.1 角色创建逻辑

```go
// Add 添加角色（多组织支持）
func (s *role) Add(ctx context.Context, req *system.RoleAddReq) (err error) {
    // 权限验证：只能在自己所属组织内创建角色
    currentUser := service.SQContext().GetLoginUser(ctx)
    if !s.canManageOrg(ctx, req.OrgID, currentUser.ID) {
        return errors.New("没有权限在该组织创建角色")
    }
    
    // 验证角色名称在同一组织下唯一
    if s.isRoleNameExists(ctx, req.OrgID, req.Name) {
        return errors.New("该组织下已存在同名角色")
    }
    
    // 过滤权限ID
    req.MenuIDs, err = s.filterRuleIDs(ctx, req.MenuIDs)
    if err != nil {
        return fmt.Errorf("过滤规则失败: %w", err)
    }
    
    err = g.DB().Transaction(ctx, func(ctx context.Context, tx gdb.TX) (err error) {
        // 创建角色记录
        roleId, err := dao.Role.Ctx(ctx).TX(tx).InsertAndGetId(map[string]interface{}{
            dao.Role.Columns().OrgID:    req.OrgID,    // 组织ID
            dao.Role.Columns().Pid:      req.Pid,      // 父角色ID
            dao.Role.Columns().Name:     req.Name,     // 角色名称
            dao.Role.Columns().Status:   model.RoleStatusEnabled,
            dao.Role.Columns().CreatorID: currentUser.ID,
        })
        if err != nil {
            return fmt.Errorf("添加角色失败: %w", err)
        }
        
        // 分配权限
        if len(req.MenuIDs) > 0 {
            err = s.addRoleRule(ctx, roleId, req.MenuIDs)
            if err != nil {
                return fmt.Errorf("添加角色权限失败: %w", err)
            }
        }
        
        // 清除缓存
        service.Cache().Remove(ctx, consts.CacheSysRole)
        return nil
    })
    return
}
```

### 2.2 角色查询逻辑

```go
// GetRoleList 获取角色列表（多组织支持）
func (s *role) GetRoleList(ctx context.Context, orgID int64) (list []*model.Role, err error) {
    cache := service.Cache()
    cacheKey := fmt.Sprintf("%s_%d", consts.CacheSysRole, orgID)
    
    // 从缓存获取，按组织隔离
    iList := cache.GetOrSetFuncLock(ctx, cacheKey, func() (interface{}, error) {
        return s.getFromDBByOrg(ctx, orgID)
    }, 0, consts.CacheSysAuthTag)
    
    if !iList.IsEmpty() {
        err = gconv.Struct(iList, &list)
    }
    return
}

// getFromDBByOrg 从数据库获取指定组织的角色
func (s *role) getFromDBByOrg(ctx context.Context, orgID int64) (value interface{}, err error) {
    err = g.Try(ctx, func(ctx context.Context) {
        var list []*entity.Role
        // 按组织ID过滤
        err = dao.Role.Ctx(ctx).Where(dao.Role.Columns().OrgID, orgID).Scan(&list)
        liberr.ErrIsNil(ctx, err, "获取角色数据失败")
        
        var out []*model.Role
        for _, v := range list {
            out = append(out, s.convertEntityToLogics(v))
        }
        value = out
    })
    return
}
```

### 2.3 权限验证逻辑

```go
// hasManageAccess 检查是否有管理指定角色的权限（多组织支持）
func (s *role) hasManageAccess(ctx context.Context, roleId int64, includeChildren bool) bool {
    currentUserId := service.SQContext().GetUserId(ctx)
    
    // 超级管理员拥有所有权限
    if service.User().IsSupperAdmin(ctx, currentUserId) {
        return true
    }
    
    // 获取角色信息
    role, err := s.Get(ctx, roleId)
    if err != nil {
        g.Log().Error(ctx, err)
        return false
    }
    
    // 检查是否有权限管理该组织
    if !s.canManageOrg(ctx, role.OrgID, currentUserId) {
        return false
    }
    
    // 检查是否是当前用户创建的角色
    if role.CreatorID == currentUserId {
        return true
    }
    
    // 检查用户是否有该角色的管理权限
    userRoleIds, err := service.User().GetUserRoleIDs(ctx, currentUserId, includeChildren)
    if err != nil {
        g.Log().Error(ctx, err)
        return false
    }
    
    for _, userRoleId := range userRoleIds {
        if userRoleId == roleId {
            return true
        }
    }
    
    return false
}

// canManageOrg 检查用户是否有权限管理指定组织
func (s *role) canManageOrg(ctx context.Context, orgID int64, userID string) bool {
    // 获取用户所属的组织列表
    userOrgs, err := service.User().GetUserOrgIDs(ctx, userID)
    if err != nil {
        g.Log().Error(ctx, err)
        return false
    }
    
    // 检查用户是否属于该组织或其子组织
    for _, userOrgID := range userOrgs {
        if userOrgID == orgID || s.isChildOrg(ctx, userOrgID, orgID) {
            return true
        }
    }
    
    return false
}
```

## 3. 数据模型调整

### 3.1 角色模型

```go
// Role 角色模型
type Role struct {
    ID        int64           `json:"id"`         // 角色ID
    OrgID     int64           `json:"org_id"`     // 组织ID
    PID       int64           `json:"pid"`        // 父角色ID
    Name      string          `json:"name"`       // 角色名称
    Status    RoleStatus      `json:"status"`     // 角色状态
    CreatorID string          `json:"creator_id"` // 创建者ID
    CreatedAt *gtime.Time     `json:"created_at"` // 创建时间
    UpdatedAt *gtime.Time     `json:"updated_at"` // 更新时间
    
    // 扩展字段
    OrgName   string          `json:"org_name"`   // 组织名称
    UserCount int             `json:"user_count"` // 用户数量
}
```

### 3.2 API请求结构

```go
// RoleAddReq 添加角色请求
type RoleAddReq struct {
    OrgID    int64   `json:"org_id" v:"required#组织ID不能为空"`    // 组织ID
    PID      int64   `json:"pid"`                                // 父角色ID
    Name     string  `json:"name" v:"required#角色名称不能为空"`    // 角色名称
    MenuIDs  []int64 `json:"menu_ids"`                          // 菜单权限ID列表
}

// RoleEditReq 编辑角色请求
type RoleEditReq struct {
    ID       int64   `json:"id" v:"required#角色ID不能为空"`      // 角色ID
    OrgID    int64   `json:"org_id" v:"required#组织ID不能为空"`   // 组织ID
    PID      int64   `json:"pid"`                               // 父角色ID
    Name     string  `json:"name" v:"required#角色名称不能为空"`   // 角色名称
    Status   int     `json:"status"`                            // 角色状态
    MenuIDs  []int64 `json:"menu_ids"`                         // 菜单权限ID列表
}
```

## 4. 缓存策略调整

### 4.1 按组织隔离缓存

```go
// 缓存键设计
const (
    CacheSysRole = "sys_role"  // 角色缓存前缀
)

// 获取角色缓存键
func getRoleCacheKey(orgID int64) string {
    return fmt.Sprintf("%s_%d", CacheSysRole, orgID)
}

// 清除角色缓存
func clearRoleCache(ctx context.Context, orgID int64) {
    cacheKey := getRoleCacheKey(orgID)
    service.Cache().Remove(ctx, cacheKey)
}
```

## 5. 权限隔离策略

### 5.1 组织级权限隔离

```go
// 权限检查时需要考虑组织隔离
func (s *role) checkPermission(ctx context.Context, userID string, orgID int64, resourceID int64) bool {
    // 1. 检查用户是否属于该组织
    if !s.userBelongsToOrg(ctx, userID, orgID) {
        return false
    }
    
    // 2. 获取用户在指定组织内的角色
    roleIDs := s.getUserRoleIDsInOrg(ctx, userID, orgID)
    
    // 3. 检查角色权限
    enforcer, _ := service.CasbinEnforcer(ctx)
    for _, roleID := range roleIDs {
        hasPermission, _ := enforcer.Enforce(
            gconv.String(roleID),
            gconv.String(resourceID),
            "All"
        )
        if hasPermission {
            return true
        }
    }
    
    return false
}
```

## 6. 数据迁移方案

### 6.1 迁移脚本

```sql
-- 1. 添加组织字段
ALTER TABLE `t_role` ADD COLUMN `org_id` INT(10) NOT NULL DEFAULT 1 COMMENT '组织ID' AFTER `id`;

-- 2. 添加索引
ALTER TABLE `t_role` ADD INDEX `idx_org_id`(`org_id`);
ALTER TABLE `t_role` ADD UNIQUE KEY `uk_org_name`(`org_id`, `name`);

-- 3. 更新现有数据（假设默认组织ID为1）
UPDATE `t_role` SET `org_id` = 1 WHERE `org_id` = 0 OR `org_id` IS NULL;

-- 4. 移除默认值
ALTER TABLE `t_role` MODIFY COLUMN `org_id` INT(10) NOT NULL COMMENT '组织ID';
```

## 7. 最佳实践

### 7.1 组织管理
1. **组织层级**：支持多级组织架构
2. **权限继承**：子组织可以继承父组织的权限
3. **数据隔离**：确保不同组织的数据完全隔离

### 7.2 角色管理
1. **组织内唯一**：同一组织下角色名称唯一
2. **权限范围**：角色只能管理本组织及子组织
3. **创建限制**：只能在自己所属组织内创建角色

### 7.3 性能优化
1. **缓存策略**：按组织隔离缓存
2. **索引优化**：为组织相关字段添加索引
3. **查询优化**：使用组织ID过滤减少数据量

## 8. 注意事项

1. **数据一致性**：确保角色与组织的关联关系正确
2. **权限边界**：明确各组织的权限边界
3. **性能考虑**：大量组织时需要考虑查询性能
4. **迁移风险**：数据迁移时需要充分测试 